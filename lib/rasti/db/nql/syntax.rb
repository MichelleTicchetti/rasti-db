# Autogenerated from a Treetop grammar. Edits may be lost.


module Rasti
  module DB
    module NQL
      module Syntax
        include Treetop::Runtime

        def root
          @root ||= :sentence
        end

        module Sentence0
          def optional_space1
            elements[0]
          end

          def sentence
            elements[1]
          end

          def optional_space2
            elements[2]
          end
        end

        def _nt_sentence
          start_index = index
          if node_cache[:sentence].has_key?(index)
            cached = node_cache[:sentence][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          r1 = _nt_optional_space
          s0 << r1
          if r1
            r2 = _nt_proposition
            s0 << r2
            if r2
              r3 = _nt_optional_space
              s0 << r3
            end
          end
          if s0.last
            r0 = instantiate_node(Sentence,input, i0...index, s0)
            r0.extend(Sentence0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:sentence][start_index] = r0

          r0
        end

        module Proposition0
          def left
            elements[0]
          end

          def mandatory_space1
            elements[1]
          end

          def mandatory_space2
            elements[3]
          end

          def right
            elements[4]
          end
        end

        def _nt_proposition
          start_index = index
          if node_cache[:proposition].has_key?(index)
            cached = node_cache[:proposition][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          i1, s1 = index, []
          r2 = _nt_conjunction
          s1 << r2
          if r2
            r3 = _nt_mandatory_space
            s1 << r3
            if r3
              if has_terminal?('|', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('|')
                r4 = nil
              end
              s1 << r4
              if r4
                r5 = _nt_mandatory_space
                s1 << r5
                if r5
                  r6 = _nt_proposition
                  s1 << r6
                end
              end
            end
          end
          if s1.last
            r1 = instantiate_node(Disjunction,input, i1...index, s1)
            r1.extend(Proposition0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            r0 = r1
          else
            r7 = _nt_conjunction
            if r7
              r0 = r7
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:proposition][start_index] = r0

          r0
        end

        module Conjunction0
          def left
            elements[0]
          end

          def mandatory_space1
            elements[1]
          end

          def mandatory_space2
            elements[3]
          end

          def right
            elements[4]
          end
        end

        def _nt_conjunction
          start_index = index
          if node_cache[:conjunction].has_key?(index)
            cached = node_cache[:conjunction][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          i1, s1 = index, []
          r2 = _nt_statement
          s1 << r2
          if r2
            r3 = _nt_mandatory_space
            s1 << r3
            if r3
              if has_terminal?('&', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('&')
                r4 = nil
              end
              s1 << r4
              if r4
                r5 = _nt_mandatory_space
                s1 << r5
                if r5
                  r6 = _nt_conjunction
                  s1 << r6
                end
              end
            end
          end
          if s1.last
            r1 = instantiate_node(Conjunction,input, i1...index, s1)
            r1.extend(Conjunction0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            r0 = r1
          else
            r7 = _nt_statement
            if r7
              r0 = r7
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:conjunction][start_index] = r0

          r0
        end

        def _nt_statement
          start_index = index
          if node_cache[:statement].has_key?(index)
            cached = node_cache[:statement][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          r1 = _nt_parenthesis_sentence
          if r1
            r0 = r1
          else
            r2 = _nt_boolean_comparison
            if r2
              r0 = r2
            else
              r3 = _nt_quantity_comparison
              if r3
                r0 = r3
              else
                r4 = _nt_string_comparison
                if r4
                  r0 = r4
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end

          node_cache[:statement][start_index] = r0

          r0
        end

        module ParenthesisSentence0
          def optional_space1
            elements[1]
          end

          def sentence
            elements[2]
          end

          def optional_space2
            elements[3]
          end

        end

        def _nt_parenthesis_sentence
          start_index = index
          if node_cache[:parenthesis_sentence].has_key?(index)
            cached = node_cache[:parenthesis_sentence][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          if has_terminal?('(', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('(')
            r1 = nil
          end
          s0 << r1
          if r1
            r2 = _nt_optional_space
            s0 << r2
            if r2
              r3 = _nt_sentence
              s0 << r3
              if r3
                r4 = _nt_optional_space
                s0 << r4
                if r4
                  if has_terminal?(')', false, index)
                    r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(')')
                    r5 = nil
                  end
                  s0 << r5
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(ParenthesisSentence,input, i0...index, s0)
            r0.extend(ParenthesisSentence0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:parenthesis_sentence][start_index] = r0

          r0
        end

        module BooleanComparison0
          def left
            elements[0]
          end

          def optional_space1
            elements[1]
          end

          def comparator
            elements[2]
          end

          def optional_space2
            elements[3]
          end

          def right
            elements[4]
          end
        end

        def _nt_boolean_comparison
          start_index = index
          if node_cache[:boolean_comparison].has_key?(index)
            cached = node_cache[:boolean_comparison][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          r1 = _nt_field
          s0 << r1
          if r1
            r2 = _nt_optional_space
            s0 << r2
            if r2
              r3 = _nt_string_comparator
              s0 << r3
              if r3
                r4 = _nt_optional_space
                s0 << r4
                if r4
                  r5 = _nt_boolean
                  s0 << r5
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(BooleanComparison,input, i0...index, s0)
            r0.extend(BooleanComparison0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:boolean_comparison][start_index] = r0

          r0
        end

        module QuantityComparison0
          def left
            elements[0]
          end

          def optional_space1
            elements[1]
          end

          def comparator
            elements[2]
          end

          def optional_space2
            elements[3]
          end

          def right
            elements[4]
          end
        end

        def _nt_quantity_comparison
          start_index = index
          if node_cache[:quantity_comparison].has_key?(index)
            cached = node_cache[:quantity_comparison][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          r1 = _nt_field
          s0 << r1
          if r1
            r2 = _nt_optional_space
            s0 << r2
            if r2
              r3 = _nt_quantity_comparator
              s0 << r3
              if r3
                r4 = _nt_optional_space
                s0 << r4
                if r4
                  r5 = _nt_quantity
                  s0 << r5
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(QuantityComparison,input, i0...index, s0)
            r0.extend(QuantityComparison0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:quantity_comparison][start_index] = r0

          r0
        end

        module StringComparison0
          def left
            elements[0]
          end

          def optional_space1
            elements[1]
          end

          def comparator
            elements[2]
          end

          def optional_space2
            elements[3]
          end

          def right
            elements[4]
          end
        end

        def _nt_string_comparison
          start_index = index
          if node_cache[:string_comparison].has_key?(index)
            cached = node_cache[:string_comparison][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          r1 = _nt_field
          s0 << r1
          if r1
            r2 = _nt_optional_space
            s0 << r2
            if r2
              r3 = _nt_string_comparator
              s0 << r3
              if r3
                r4 = _nt_optional_space
                s0 << r4
                if r4
                  r5 = _nt_text
                  s0 << r5
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(StringComparison,input, i0...index, s0)
            r0.extend(StringComparison0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:string_comparison][start_index] = r0

          r0
        end

        module Field0
          def field_name
            elements[0]
          end

        end

        module Field1
          def tables
            elements[0]
          end

          def name
            elements[1]
          end
        end

        def _nt_field
          start_index = index
          if node_cache[:field].has_key?(index)
            cached = node_cache[:field][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          s1, i1 = [], index
          loop do
            i2, s2 = index, []
            r3 = _nt_field_name
            s2 << r3
            if r3
              if has_terminal?('.', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('.')
                r4 = nil
              end
              s2 << r4
            end
            if s2.last
              r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
              r2.extend(Field0)
            else
              @index = i2
              r2 = nil
            end
            if r2
              s1 << r2
            else
              break
            end
          end
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          s0 << r1
          if r1
            r5 = _nt_field_name
            s0 << r5
          end
          if s0.last
            r0 = instantiate_node(Field,input, i0...index, s0)
            r0.extend(Field1)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:field][start_index] = r0

          r0
        end

        def _nt_string_comparator
          start_index = index
          if node_cache[:string_comparator].has_key?(index)
            cached = node_cache[:string_comparator][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          if has_terminal?(':', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(':')
            r1 = nil
          end
          if r1
            r0 = r1
          else
            if has_terminal?('!:', false, index)
              r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('!:')
              r2 = nil
            end
            if r2
              r0 = r2
            else
              if has_terminal?('~', false, index)
                r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('~')
                r3 = nil
              end
              if r3
                r0 = r3
              else
                r4 = _nt_boolean_comparator
                if r4
                  r0 = r4
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end

          node_cache[:string_comparator][start_index] = r0

          r0
        end

        def _nt_quantity_comparator
          start_index = index
          if node_cache[:quantity_comparator].has_key?(index)
            cached = node_cache[:quantity_comparator][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          if has_terminal?('>=', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('>=')
            r1 = nil
          end
          if r1
            r0 = r1
          else
            if has_terminal?('<=', false, index)
              r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
              @index += 2
            else
              terminal_parse_failure('<=')
              r2 = nil
            end
            if r2
              r0 = r2
            else
              if has_terminal?('>', false, index)
                r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('>')
                r3 = nil
              end
              if r3
                r0 = r3
              else
                if has_terminal?('<', false, index)
                  r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure('<')
                  r4 = nil
                end
                if r4
                  r0 = r4
                else
                  r5 = _nt_boolean_comparator
                  if r5
                    r0 = r5
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end

          node_cache[:quantity_comparator][start_index] = r0

          r0
        end

        def _nt_boolean_comparator
          start_index = index
          if node_cache[:boolean_comparator].has_key?(index)
            cached = node_cache[:boolean_comparator][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          if has_terminal?('!=', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('!=')
            r1 = nil
          end
          if r1
            r0 = r1
          else
            if has_terminal?('=', false, index)
              r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('=')
              r2 = nil
            end
            if r2
              r0 = r2
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:boolean_comparator][start_index] = r0

          r0
        end

        def _nt_quantity
          start_index = index
          if node_cache[:quantity].has_key?(index)
            cached = node_cache[:quantity][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          r1 = _nt_integer
          if r1
            r0 = r1
          else
            r2 = _nt_float
            if r2
              r0 = r2
            else
              r3 = _nt_time
              if r3
                r0 = r3
              else
                @index = i0
                r0 = nil
              end
            end
          end

          node_cache[:quantity][start_index] = r0

          r0
        end

        def _nt_text
          start_index = index
          if node_cache[:text].has_key?(index)
            cached = node_cache[:text][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          r1 = _nt_literal_string
          if r1
            r0 = r1
          else
            r2 = _nt_string
            if r2
              r0 = r2
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:text][start_index] = r0

          r0
        end

        def _nt_optional_space
          start_index = index
          if node_cache[:optional_space].has_key?(index)
            cached = node_cache[:optional_space][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          s0, i0 = [], index
          loop do
            if has_terminal?('\G[\\s\\t\\n]', true, index)
              r1 = true
              @index += 1
            else
              r1 = nil
            end
            if r1
              s0 << r1
            else
              break
            end
          end
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

          node_cache[:optional_space][start_index] = r0

          r0
        end

        def _nt_mandatory_space
          start_index = index
          if node_cache[:mandatory_space].has_key?(index)
            cached = node_cache[:mandatory_space][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          s0, i0 = [], index
          loop do
            if has_terminal?('\G[\\s\\t\\n]', true, index)
              r1 = true
              @index += 1
            else
              r1 = nil
            end
            if r1
              s0 << r1
            else
              break
            end
          end
          if s0.empty?
            @index = i0
            r0 = nil
          else
            r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          end

          node_cache[:mandatory_space][start_index] = r0

          r0
        end

        def _nt_field_name
          start_index = index
          if node_cache[:field_name].has_key?(index)
            cached = node_cache[:field_name][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          s0, i0 = [], index
          loop do
            if has_terminal?('\G[a-z]', true, index)
              r1 = true
              @index += 1
            else
              r1 = nil
            end
            if r1
              s0 << r1
            else
              break
            end
          end
          if s0.empty?
            @index = i0
            r0 = nil
          else
            r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          end

          node_cache[:field_name][start_index] = r0

          r0
        end

        module Time0
          def value
            elements[0]
          end

        end

        module Time1
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Time2
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Time3
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Time4
          def value
            elements[1]
          end
        end

        module Time5
          def date
            elements[0]
          end

          def hour
            elements[1]
          end

          def minutes
            elements[3]
          end

          def seconds
            elements[4]
          end

          def timezone
            elements[5]
          end
        end

        def _nt_time
          start_index = index
          if node_cache[:time].has_key?(index)
            cached = node_cache[:time][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          i2, s2 = index, []
          r3 = _nt_date
          s2 << r3
          if r3
            if has_terminal?('T', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('T')
              r4 = nil
            end
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(Time0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r1 = r2
          else
            r1 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r1
          if r1
            i5, s5 = index, []
            r6 = _nt_digit
            s5 << r6
            if r6
              r7 = _nt_digit
              s5 << r7
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(Time1)
            else
              @index = i5
              r5 = nil
            end
            s0 << r5
            if r5
              if has_terminal?(':', false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(':')
                r8 = nil
              end
              s0 << r8
              if r8
                i9, s9 = index, []
                r10 = _nt_digit
                s9 << r10
                if r10
                  r11 = _nt_digit
                  s9 << r11
                end
                if s9.last
                  r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                  r9.extend(Time2)
                else
                  @index = i9
                  r9 = nil
                end
                s0 << r9
                if r9
                  i13, s13 = index, []
                  if has_terminal?(':', false, index)
                    r14 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(':')
                    r14 = nil
                  end
                  s13 << r14
                  if r14
                    i15, s15 = index, []
                    r16 = _nt_digit
                    s15 << r16
                    if r16
                      r17 = _nt_digit
                      s15 << r17
                    end
                    if s15.last
                      r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
                      r15.extend(Time3)
                    else
                      @index = i15
                      r15 = nil
                    end
                    s13 << r15
                  end
                  if s13.last
                    r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                    r13.extend(Time4)
                  else
                    @index = i13
                    r13 = nil
                  end
                  if r13
                    r12 = r13
                  else
                    r12 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r12
                  if r12
                    r19 = _nt_timezone
                    if r19
                      r18 = r19
                    else
                      r18 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r18
                  end
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(TimeConstant,input, i0...index, s0)
            r0.extend(Time5)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:time][start_index] = r0

          r0
        end

        module Date0
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end

          def digit3
            elements[2]
          end

          def digit4
            elements[3]
          end
        end

        module Date1
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Date2
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Date3
          def year
            elements[0]
          end

          def month
            elements[2]
          end

          def day
            elements[4]
          end
        end

        def _nt_date
          start_index = index
          if node_cache[:date].has_key?(index)
            cached = node_cache[:date][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          i1, s1 = index, []
          r2 = _nt_digit
          s1 << r2
          if r2
            r3 = _nt_digit
            s1 << r3
            if r3
              r4 = _nt_digit
              s1 << r4
              if r4
                r5 = _nt_digit
                s1 << r5
              end
            end
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Date0)
          else
            @index = i1
            r1 = nil
          end
          s0 << r1
          if r1
            if has_terminal?('-', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('-')
              r6 = nil
            end
            s0 << r6
            if r6
              i7, s7 = index, []
              r8 = _nt_digit
              s7 << r8
              if r8
                r9 = _nt_digit
                s7 << r9
              end
              if s7.last
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                r7.extend(Date1)
              else
                @index = i7
                r7 = nil
              end
              s0 << r7
              if r7
                if has_terminal?('-', false, index)
                  r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure('-')
                  r10 = nil
                end
                s0 << r10
                if r10
                  i11, s11 = index, []
                  r12 = _nt_digit
                  s11 << r12
                  if r12
                    r13 = _nt_digit
                    s11 << r13
                  end
                  if s11.last
                    r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                    r11.extend(Date2)
                  else
                    @index = i11
                    r11 = nil
                  end
                  s0 << r11
                end
              end
            end
          end
          if s0.last
            r0 = instantiate_node(Date,input, i0...index, s0)
            r0.extend(Date3)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:date][start_index] = r0

          r0
        end

        module Timezone0
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Timezone1
          def digit1
            elements[0]
          end

          def digit2
            elements[1]
          end
        end

        module Timezone2
          def sign
            elements[0]
          end

          def hour
            elements[1]
          end

          def minutes
            elements[3]
          end
        end

        def _nt_timezone
          start_index = index
          if node_cache[:timezone].has_key?(index)
            cached = node_cache[:timezone][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          r1 = _nt_sign
          s0 << r1
          if r1
            i2, s2 = index, []
            r3 = _nt_digit
            s2 << r3
            if r3
              r4 = _nt_digit
              s2 << r4
            end
            if s2.last
              r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
              r2.extend(Timezone0)
            else
              @index = i2
              r2 = nil
            end
            s0 << r2
            if r2
              if has_terminal?(':', false, index)
                r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(':')
                r5 = nil
              end
              s0 << r5
              if r5
                i6, s6 = index, []
                r7 = _nt_digit
                s6 << r7
                if r7
                  r8 = _nt_digit
                  s6 << r8
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(Timezone1)
                else
                  @index = i6
                  r6 = nil
                end
                s0 << r6
              end
            end
          end
          if s0.last
            r0 = instantiate_node(TimeZone,input, i0...index, s0)
            r0.extend(Timezone2)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:timezone][start_index] = r0

          r0
        end

        def _nt_sign
          start_index = index
          if node_cache[:sign].has_key?(index)
            cached = node_cache[:sign][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          if has_terminal?('+', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('+')
            r1 = nil
          end
          if r1
            r0 = r1
          else
            if has_terminal?('-', false, index)
              r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('-')
              r2 = nil
            end
            if r2
              r0 = r2
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:sign][start_index] = r0

          r0
        end

        module LiteralString0
          def value
            elements[1]
          end

        end

        def _nt_literal_string
          start_index = index
          if node_cache[:literal_string].has_key?(index)
            cached = node_cache[:literal_string][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          if has_terminal?('"', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('"')
            r1 = nil
          end
          s0 << r1
          if r1
            r2 = _nt_string
            s0 << r2
            if r2
              if has_terminal?('"', false, index)
                r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('"')
                r3 = nil
              end
              s0 << r3
            end
          end
          if s0.last
            r0 = instantiate_node(LiteralStringConstant,input, i0...index, s0)
            r0.extend(LiteralString0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:literal_string][start_index] = r0

          r0
        end

        module String0
          def value
            elements[0]
          end
        end

        def _nt_string
          start_index = index
          if node_cache[:string].has_key?(index)
            cached = node_cache[:string][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          s1, i1 = [], index
          loop do
            r2 = _nt_character
            if r2
              s1 << r2
            else
              break
            end
          end
          if s1.empty?
            @index = i1
            r1 = nil
          else
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          end
          s0 << r1
          if s0.last
            r0 = instantiate_node(StringConstant,input, i0...index, s0)
            r0.extend(String0)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:string][start_index] = r0

          r0
        end

        def _nt_character
          start_index = index
          if node_cache[:character].has_key?(index)
            cached = node_cache[:character][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?('\G[0-9a-zA-ZÁÀÄÂÃÅĀĂǍáàäâãåāăǎÉÈËÊĒĔĖĚéèëêēĕėěÍÌÏÎĨĬǏíìïîĩĭǐÓÒÖÔÕŌŎŐǑóòöôõōŏőǒÚÙÜÛŨŪŬŮŰǓúùüûũūŭůűǔÑñçÇ%&@#\\+\\-_=ß\'\\?!$\\*\\/\\s\\(\\)]', true, index)
            r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            r0 = nil
          end

          node_cache[:character][start_index] = r0

          r0
        end

        def _nt_boolean
          start_index = index
          if node_cache[:boolean].has_key?(index)
            cached = node_cache[:boolean][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          r1 = _nt_true
          if r1
            r0 = r1
          else
            r2 = _nt_false
            if r2
              r0 = r2
            else
              @index = i0
              r0 = nil
            end
          end

          node_cache[:boolean][start_index] = r0

          r0
        end

        def _nt_true
          start_index = index
          if node_cache[:true].has_key?(index)
            cached = node_cache[:true][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?('true', false, index)
            r0 = instantiate_node(TrueConstant,input, index...(index + 4))
            @index += 4
          else
            terminal_parse_failure('true')
            r0 = nil
          end

          node_cache[:true][start_index] = r0

          r0
        end

        def _nt_false
          start_index = index
          if node_cache[:false].has_key?(index)
            cached = node_cache[:false][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?('false', false, index)
            r0 = instantiate_node(FalseConstant,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure('false')
            r0 = nil
          end

          node_cache[:false][start_index] = r0

          r0
        end

        module Float0
        end

        module Float1
        end

        def _nt_float
          start_index = index
          if node_cache[:float].has_key?(index)
            cached = node_cache[:float][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0, s0 = index, []
          s1, i1 = [], index
          loop do
            r2 = _nt_digit
            if r2
              s1 << r2
            else
              break
            end
          end
          if s1.empty?
            @index = i1
            r1 = nil
          else
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          end
          s0 << r1
          if r1
            i4, s4 = index, []
            if has_terminal?('.', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('.')
              r5 = nil
            end
            s4 << r5
            if r5
              s6, i6 = [], index
              loop do
                r7 = _nt_digit
                if r7
                  s6 << r7
                else
                  break
                end
              end
              if s6.empty?
                @index = i6
                r6 = nil
              else
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              end
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(Float0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
          end
          if s0.last
            r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
            r0.extend(Float1)
          else
            @index = i0
            r0 = nil
          end

          node_cache[:float][start_index] = r0

          r0
        end

        def _nt_integer
          start_index = index
          if node_cache[:integer].has_key?(index)
            cached = node_cache[:integer][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          s0, i0 = [], index
          loop do
            r1 = _nt_digit
            if r1
              s0 << r1
            else
              break
            end
          end
          if s0.empty?
            @index = i0
            r0 = nil
          else
            r0 = instantiate_node(IntegerConstant,input, i0...index, s0)
          end

          node_cache[:integer][start_index] = r0

          r0
        end

        def _nt_digit
          start_index = index
          if node_cache[:digit].has_key?(index)
            cached = node_cache[:digit][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?('\G[0-9]', true, index)
            r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            r0 = nil
          end

          node_cache[:digit][start_index] = r0

          r0
        end

      end

      class SyntaxParser < Treetop::Runtime::CompiledParser
        include Syntax
      end

    end
  end
end